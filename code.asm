;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	07/01/2022
;	Project: Fun Binary Counter
;    Momin Abdelhafez	- 1181893
;	 Ghaydaa Khateeb    - 1180681
;		   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;======================< Processer Configuration >================;
PROCESSOR 16F877A	; PROCESSER
__CONFIG 0X3731		; THIS IS IMPORTANT FOR THE CRYSTAL OSSCILATOR
;=================================================================;

;=====================< Label and variables ======================;
INCLUDE "P16F877A.INC"
CURRENT_PERIOD      EQU 20H				; REGISTER FOR STORING CURRENT PERIO D
STEP_SIZE           EQU 21H				; STEP SIZE , 1 2 3 4 5 1 2 3 4 5 .. ETC
NUMBER_STEPS        EQU 22H				; NUMBER OF TMR1 INTERRUPT OCCURENCES
TEMP          	    EQU 23H				; TEMP VARIABLE
THRESHOLD_STEP      EQU 24H				; TO COMPARE IT WITH 5
THRESHOLD_DELAY     EQU 25H             ; TO COMPARE IT WITH 5
;=================================================================;

			
			ORG 000								; BANK0 SELECTION	
			GOTO INIT							; MAKE PROPER INITIALIZATION
			
			;================================< INTERRUPT SERVICE ROUTINE <ISR> >=============================================;
			ORG 004								; SELECT BANK 4 WHICH REPRESENT THE ISR WHICH STORES THE INTERRUPTS ROUTINES
		
			BANKSEL PORTA						; SELECT BANK 0 WITH THE USE OF PORTA
			
			MOVLW D'0'							; STORING 0 IN THE ACCUMULATOR
			MOVWF INTCON						; STORE IT IN THE INTCON -> TURNING OFF ALL TYPES OF INTERRUPTS
			
			BTFSC PIR1, TMR1IF					; CHECK IF TMR1 OVERFLOW INTERRUPT OCCURED
			GOTO TMR1_INTERRUPT						
			
			BANKSEL PORTB						; SELECT BANK0	
			MOVF PORTB							; READING THE CONTENT OF PORTB 
			
			; -------- HERE WE WILL ARE GING TO CHECK WHICH INTERRUPT NEEDS TO BE SERVED
			BTFSS PORTB, 4 						; BUTTON WHICH USED TO INCREMENT STEP OF COUNTING IS CONNECTED TO RB4
			GOTO  INC_COUNTING_STEP  			; IF BUTTON 1 WAS CLICKED, THE STEP WILL INCREMENT STEP
			BTFSS PORTB, 5 						; BUTTON WHICH USED TO INC DELAY IS CONNECTED TO RB5
			GOTO 	INC_DELAY				    ; IF BUTTON 2 WAS CLICKED, INCREMENT DELAY
				
		
			END_INTERRUPT		
					BANKSEL PORTB 				; SELECTION BANK WHICH PORTB STANDS
					CLRF PORTB					; CLEAR PORTB
					MOVLW B'11001000'			; TURN ON INTERRUPTS AGAIN, GIE, TMR1 , RB4-7 INTERRUPTS
					MOVWF INTCON
			RETFIE								; RETURN BACK FROM THE ISR 
			;================================< ENDING INTERRUPT SERVICE ROUTINE <ISR> >=============================================;
			
	        ;================================< INITIALIZTION AND STARTING OF THE MAIN PROGRAM >=====================================;
			INIT							; IN THIS INIT WE ARE GONG TO INITIALIZE THE INTCON REGISTER
			BANKSEL PORTA 	  				; FIRST WE SELECT BANK 0
			MOVLW B'11001000'				; THIS MEANS THAT WE ARE GOING TO ENABLE GIE(GLOBAL), AND TMR1(PEREPHERAL) AS WELL AS RB4-7
			MOVWF INTCON                    ; STORING THE VALUE IN THE INTCON REGISTER
			
			BSF T1CON, TMR1ON				; ENABLE TMR1 IN TIMER MODE
			
			; AS TMR1 WITH PRESCALING IS POSSIBLE TO GIVE US ONLY 0.5 SECONDS FOR INTERRUPTION
			; WE NEED TO MAKE IT TWISE TO ACHIEVE 1 SECOND
			; INTERRUPT EACH 0.5 SECOND ----> f = 2MHz
			; COUNTER = 65536 - 1MHz / (8 * 2) = (3036)D = (BDC)H
			; 8 IS THR PRESCALER OF OUR COUNTER
			; IT'S IMPOSSIBLE TO STORE 3036 IN ONE REGISTER SO WE DIVIDE IT INTO LOW AND HIGH
			MOVLW H'DC'
			MOVWF TMR1L
			MOVLW H'0B'
			MOVWF TMR1H
			
			BSF T1CON, T1CKPS1				; SETTING THE PRESCALER TO 8
			BSF T1CON, T1CKPS0				;
			
			BANKSEL ADCON1 					; SELECT BANK 1
			MOVLW H'6' 						; SETTING PORTA AS DIGITAL
			MOVWF ADCON1 					; SET PORTA AS DIGITAL
			MOVLW D'0' 						; SETTING PORTA AS DIGITAL OUTPUT
			MOVWF TRISA 					; SET PORTA PINS AS OUTPUT
			
			BANKSEL PIE1					; SELECT BANK WHERE PIE1 STANDS				
			BSF PIE1 , TMR1IE				; ENABLE TMR1 OVERFLOW INTERRUPT
			
			MOVLW B'00000000'				; SET PORTD AS OUTPUT
			MOVWF TRISD
			
			CLRF PORTB						; CLEAR PORTB WHERE OUR BUTTONS ARE
			BANKSEL TRISB					; BUT WE ARE GOING TO SET RB4 & RB5 AS INPUT
			MOVLW B'00110000'				; SELECTING RB4 & RB5 AS INPUTS
			MOVWF TRISB
			
			BANKSEL PORTD					; INITIALIZE PORTD WHERE THE OUTPUT OF OUR COUNTER TAKE PLACE WITH ZEROS
			MOVWF PORTD
			CLRF  PORTD
			
			BANKSEL PORTB					; INTIALIZATION OF STEP_SIZE AND CURRENT DELAY
			MOVLW D'5' 						; SOTRE 5 IN THE ACCUMULATOR
			MOVWF THRESHOLD_STEP			; STORE 5 IN THE STEP THRESHOLD
			MOVWF THRESHOLD_DELAY			; STORE 5 IN THE DELAY THRESHOLD
			MOVLW D'1'						; STORE 1 IN THE ACCUMULATOR
			MOVWF STEP_SIZE 				; STEP 		= 1
			MOVWF CURRENT_PERIOD 			; PERIOD 	= 1
			
			
			MOVLW H'00'						; INITIALIZE THE NUMBER OF COUNTS FOR TMR1 INTERRUPT
			MOVWF NUMBER_STEPS				; STORE THE VALUE IN NUMBER_STEPS GENERAL REGISTER
		
	
			LOOP 		NOP					; THIS IS OUR RUNNING LOOP TO KEEP THE PROGRAM RUNNING
						NOP					; NO OPERATION 
						GOTO LOOP			; GOING BACL TO LOOP TO INF
						
			;================================< END INITIALIZTION AND STARTING OF THE MAIN PROGRAM >==================================;


			INC_COUNTING_STEP							; INCREMENT STEP WHICH RELATED TO RB4 INTERRUPT, THIS ROUTINE TAKE PLACE ONCE 
														; BUTTON 1 IS CLICKED
						BANKSEL PORTA					; SELECT BANK WHERE PORTA STANDS
						INCF 	STEP_SIZE		    	; ADD 1 TO STEP_SIZE
						DECFSZ	THRESHOLD_STEP			; CHECK IF THE THRESHOLD REACH 0
						GOTO    END_INTERRUPT       	; IF NOT 0 RETURN
						GOTO    RETURN_BACK				; IF 0 REINTIALIZE THE STEP				
						RETURN_BACK MOVLW H'01'   		; STORE 1 IN THE STEP_SIZE
									MOVWF STEP_SIZE	
									MOVLW D'5'			; STORE 5 IN THE THRESHOLD STEP
									MOVWF THRESHOLD_STEP    
									GOTO END_INTERRUPT
           ;===========================================================================================================================
		
			INC_DELAY									; INCREMENT DELAY STEP WHICH RELATED TO RB5
						BANKSEL PORTA
						INCF 	CURRENT_PERIOD			; ADD 1 TO CURRENT DELAY PERIOD
						DECFSZ  THRESHOLD_DELAY         ; CHECK IF THRESHOLD DELAY REACH 0
						GOTO    END_INTERRUPT           ; IF NOT 0 RETURN
						GOTO    RETURN_BACK1			; IF 0 REINITALIZE THE CURRENT DELAY
						
						RETURN_BACK1 MOVLW H'01'        
									 MOVWF CURRENT_PERIOD    
									 MOVLW D'5'
									 MOVWF THRESHOLD_DELAY
									 GOTO END_INTERRUPT
									 
		  ;===========================================================================================================================
			TMR1_INTERRUPT	
							BANKSEL PIR1				; CLEAR TMR1 OVERFLOW INTERRUPT FLAG
							BCF PIR1, TMR1IF
						
							MOVLW H'DC'					; RESET THE COUNT AND PRESCALER
							MOVWF TMR1L					; BY STORING THE VALUE
							MOVLW H'0B'					; COUNTER = 65536 - 1MHz / (8 * 2) = (3036)D = (BDC)H
							MOVWF TMR1H
										
							BSF T1CON, T1CKPS1			; SET PRESCALER TO 8
							BSF T1CON, T1CKPS0
							
							INCF NUMBER_STEPS			; INCREMENT THE COUNTS
							
							; NOW WE ARE GOING TO CHECK IF THE PERIOD IS REACHED
							; FIRST WE DIVIDE COUNTS BY 2
							MOVF NUMBER_STEPS, W 		; STORING STEPS COUNT IN THE ACCUMULATER
							MOVWF TEMP     				; TEMP <- COUNTS
							RRF TEMP, F    				; TEMP <- TEMP / 2
							BCF TEMP, 7
							; THIS IS THE WAY THAT WE USED TO COMPARE TO VALUES
							MOVF CURRENT_PERIOD, W 	    ;STORING CURRENT PERIOD IN THE ACCUMULATOR, THEN WESUBTRACT TEMP FROM PERIOD
							SUBWF TEMP, F 				; TEMP <- TEMP - PERIOD
							BTFSS STATUS, Z 			; CHECK ZERO FLAG
							GOTO CHECK_CFLAG   			; IF Z = 0, THEN WE CHECK IF TEMP > PERIOD
							GOTO CONT_INTERRUPT			; IF Z = 1, THEN TEMP = PERIOD, WE INCREMENT PORTD
						
							CHECK_CFLAG BTFSS STATUS, C	; IF THE CARRY C = 1, THEN TEMP > PERIOD
										GOTO END_INTERRUPT
						
							CONT_INTERRUPT	
										CLRF NUMBER_STEPS; RESET COUNTS
										 				
							MOVF STEP_SIZE, W 	; STORE STEP_SIZE IN THE ACCUMULATER W <- STEP
							ADDWF PORTD, F 		; ADD THE STEP SIZE TO PORTD, PORTD <- PORTD + STEP
			
												; CHECK IF PORTD REACH 32
							BTFSC PORTD, 5		; CHECK BIT #5 IF EQUAL 1
							GOTO RESET_COUNT	; RESET PORTD COUNT IF RD5 = 1
							
							BTFSC PORTD, 6		; CHECK BIT #6 IF EQUAL 1
							GOTO RESET_COUNT	; RESET PORTD COUNT IF RD6 = 1
							
							BTFSC PORTD, 7		; CHECK BIT #7 IF EQUAL 1
							GOTO RESET_COUNT	; RESET PORTD COUNT IF RD7 = 1
							
							GOTO END_INTERRUPT
							
							RESET_COUNT				; RESET PORTD COUNT
										MOVLW H'00' 
										MOVWF PORTD
										GOTO END_INTERRUPT
									
	END